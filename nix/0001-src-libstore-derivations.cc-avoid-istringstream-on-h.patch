From 7c2d44c7f055e1c40c11f6caadc6943021bcd348 Mon Sep 17 00:00:00 2001
From: Sergei Trofimovich <slyich@gmail.com>
Date: Tue, 15 Mar 2022 08:43:12 +0000
Subject: [PATCH] src/libstore/derivations.cc: avoid istringstream on .drv
 parse path

`nix store gs --dry-run` is a mostly CPU-bound workload that spends
a lot of time in istream::get and in memcmp (seen in `perf top`):

    9,36%  libstdc++.so.6.0.28  [.] std::istream::get
    5,81%  libc-2.33.so         [.] __memcmp_avx2_movbe
    4,69%  libstdc++.so.6.0.28  [.] std::istream::sentry::sentry
    3,54%  libc-2.33.so         [.] malloc
    3,04%  libc-2.33.so         [.] _int_malloc
    2,52%  libsqlite3.so.0.8.6  [.] sqlite3VdbeExec
    2,43%  libnixstore.so       [.] nix::parseString
    2,18%  libsqlite3.so.0.8.6  [.] pcache1Fetch
    ...

Looking closer at unexpected CPU usage most of calls to `expect()` when
`.drv` files are parsed are 1-2 charasters long. The code always uses
`std::string` comparison for them where overhead is large:
std::string is constructed on heap and memcmp() is called. Similar goes for
`istream::get()` where we work one char at a time and call to
`istream::get()` takes more cycles than anything else hapens to a chanr.

The change turns most string comparisons to char comparisons effectively
eliminating most of memory allocation overheads and only leaving the
istream one.

Benchmark: my system has about 139MB, 40K `.drv` files.

Performance before the change:

    $ time nix store gc --dry-run
    real    4m22,148s

Performance after the change:

    $ time nix store gc --dry-run
    real    3m17,893s

That is a ~25% spedup. The overhead now shifted to sqlite queries
and to memory allocation/free somewhere else.

Co-authored-by: Eelco Dolstra <edolstra@gmail.com>
---
 src/libstore/derivations.cc | 123 +++++++++++++++++++++++-------------
 1 file changed, 79 insertions(+), 44 deletions(-)

diff --git a/src/libstore/derivations.cc b/src/libstore/derivations.cc
index 1fe45bd87..26da1cd96 100644
--- a/src/libstore/derivations.cc
+++ b/src/libstore/derivations.cc
@@ -103,31 +103,66 @@ StorePath writeDerivation(Store & store,
 }
 
 
-/* Read string `s' from stream `str'. */
-static void expect(std::istream & str, std::string_view s)
-{
-    char s2[s.size()];
-    str.read(s2, s.size());
-    if (std::string(s2, s.size()) != s)
-        throw FormatError("expected string '%1%'", s);
-}
+struct DerivationParserContext {
+    /* Parsed input stream. */
+    std::string_view input;
+
+    DerivationParserContext(std::string_view i)
+        : input(i)
+    { }
+
+    char peek(void) {
+        if (input.empty())
+            throw FormatError("unexpected EOF");
+        return input.front();
+    }
 
+    char get() {
+        if (input.empty())
+            throw FormatError("unexpected EOF");
+        char r = input.front();
+        input.remove_prefix(1);
+        return r;
+    }
+
+    void expect(std::string_view s)
+    {
+        size_t sz = s.size();
+        if (input.size() < sz || s != input.substr(0, sz))
+            throw FormatError("expected string '%1%'", s);
+        input.remove_prefix(sz);
+    }
 
-/* Read a C-style string from stream `str'. */
-static std::string parseString(std::istream & str)
+    void expect(char c)
+    {
+        if (get() != c)
+            throw FormatError("expected char '%1%'", c);
+    }
+};
+
+static std::string parseString(DerivationParserContext & str)
 {
     std::string res;
-    expect(str, "\"");
-    int c;
-    while ((c = str.get()) != '"')
-        if (c == '\\') {
-            c = str.get();
-            if (c == 'n') res += '\n';
-            else if (c == 'r') res += '\r';
-            else if (c == 't') res += '\t';
-            else res += c;
-        }
+    str.expect('"');
+
+    /* Scan up to first '"' (closing string) or escape. Then append to a string. */
+    for (;;) {
+        std::string_view prefix = str.input.substr(0, str.input.find_first_of("\"\\"));
+        res.append(prefix);
+        str.input.remove_prefix(prefix.size());
+
+        int c = str.get();
+        if (c == '"')
+            break;
+
+        /* Handle '\\'. */
+        c = str.get();
+        if (c == 'n') res += '\n';
+        else if (c == 'r') res += '\r';
+        else if (c == 't') res += '\t';
         else res += c;
+    }
+
     return res;
 }
 
@@ -136,7 +171,7 @@ static void validatePath(std::string_view s) {
         throw FormatError("bad path '%1%' in derivation", s);
 }
 
-static Path parsePath(std::istream & str)
+static Path parsePath(DerivationParserContext & str)
 {
     auto s = parseString(str);
     validatePath(s);
@@ -144,7 +179,7 @@ static Path parsePath(std::istream & str)
 }
 
 
-static bool endOfList(std::istream & str)
+static bool endOfList(DerivationParserContext & str)
 {
     if (str.peek() == ',') {
         str.get();
@@ -158,7 +193,7 @@ static bool endOfList(std::istream & str)
 }
 
 
-static StringSet parseStrings(std::istream & str, bool arePaths)
+static StringSet parseStrings(DerivationParserContext & str, bool arePaths)
 {
     StringSet res;
     while (!endOfList(str))
@@ -212,12 +247,12 @@ static DerivationOutput parseDerivationOutput(const Store & store,
     }
 }
 
-static DerivationOutput parseDerivationOutput(const Store & store, std::istringstream & str)
+static DerivationOutput parseDerivationOutput(const Store & store, DerivationParserContext & str)
 {
-    expect(str, ","); const auto pathS = parseString(str);
-    expect(str, ","); const auto hashAlgo = parseString(str);
-    expect(str, ","); const auto hash = parseString(str);
-    expect(str, ")");
+    str.expect(','); const auto pathS = parseString(str);
+    str.expect(','); const auto hashAlgo = parseString(str);
+    str.expect(','); const auto hash = parseString(str);
+    str.expect(')');
 
     return parseDerivationOutput(store, pathS, hashAlgo, hash);
 }
@@ -228,45 +263,45 @@ Derivation parseDerivation(const Store & store, std::string && s, std::string_vi
     Derivation drv;
     drv.name = name;
 
-    std::istringstream str(std::move(s));
-    expect(str, "Derive([");
+    DerivationParserContext str(s);
+    str.expect("Derive([");
 
     /* Parse the list of outputs. */
     while (!endOfList(str)) {
-        expect(str, "("); std::string id = parseString(str);
+        str.expect('('); std::string id = parseString(str);
         auto output = parseDerivationOutput(store, str);
         drv.outputs.emplace(std::move(id), std::move(output));
     }
 
     /* Parse the list of input derivations. */
-    expect(str, ",[");
+    str.expect(','); str.expect('[');
     while (!endOfList(str)) {
-        expect(str, "(");
+        str.expect('(');
         Path drvPath = parsePath(str);
-        expect(str, ",[");
+        str.expect(",[");
         drv.inputDrvs.insert_or_assign(store.parseStorePath(drvPath), parseStrings(str, false));
-        expect(str, ")");
+        str.expect(')');
     }
 
-    expect(str, ",["); drv.inputSrcs = store.parseStorePathSet(parseStrings(str, true));
-    expect(str, ","); drv.platform = parseString(str);
-    expect(str, ","); drv.builder = parseString(str);
+    str.expect(','); str.expect('['); drv.inputSrcs = store.parseStorePathSet(parseStrings(str, true));
+    str.expect(','); drv.platform = parseString(str);
+    str.expect(','); drv.builder = parseString(str);
 
     /* Parse the builder arguments. */
-    expect(str, ",[");
+    str.expect(','); str.expect('[');
     while (!endOfList(str))
         drv.args.push_back(parseString(str));
 
     /* Parse the environment variables. */
-    expect(str, ",[");
+    str.expect(','); str.expect('[');
     while (!endOfList(str)) {
-        expect(str, "("); auto name = parseString(str);
-        expect(str, ","); auto value = parseString(str);
-        expect(str, ")");
+        str.expect('('); auto name = parseString(str);
+        str.expect(','); auto value = parseString(str);
+        str.expect(')');
         drv.env[name] = value;
     }
 
-    expect(str, ")");
+    str.expect(')');
     return drv;
 }
 
-- 
2.35.1

